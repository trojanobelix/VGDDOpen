<?xml version="1.0" encoding="utf-8" ?>
<VGDDCodeTemplate>
    <ProjectTemplates>
        <Header>
            <![CDATA[
#ifndef	_VGDD_SCREENS_H_
#define	 _VGDD_SCREENS_H_
[HEADERSINCLUDES]]]>
        </Header>
        <CodeHead>
            <![CDATA[
// VGDD Project [PROJECT_NAME] using Legacy MLA
//
// This code is automatically generated by
//    Visual Graphics Display Designer
//
//       (c) 2011-2016 VirtualFab
//
//        DO NOT MANUALLY MODIFY
//
#define _VGDD_
#include "Graphics/Graphics.h"
#include "[PROJECTFILENAME_SCREENSH]"
]]>
        </CodeHead>
        <TextDeclare>
            <Null>
                <Header>
                </Header>
                <CodeHead>
                </CodeHead>
            </Null>
            <ConstXcharArray>
                <Header>
                </Header>
                <CodeHead>
                    <![CDATA[
const XCHAR [CONTROLID]_Text[] = [QTEXT]; // [TEXT]
]]>
                </CodeHead>
            </ConstXcharArray>
            <RamXcharArray>
                <Header>
                    <![CDATA[
extern XCHAR [CONTROLID]_Text[];
]]>
                </Header>
                <CodeHead>
                    <![CDATA[
XCHAR [CONTROLID]_Text[[CHARMAX]] = [QTEXT]; // [TEXT]
]]>
                </CodeHead>
            </RamXcharArray>
            <ExternXcharPointer>
                <Header>
                </Header>
                <CodeHead>
                    <![CDATA[
extern XCHAR *[CONTROLID_NOINDEX]_Text;
]]>
                </CodeHead>
            </ExternXcharPointer>
            <ExternRamXCharArray>
                <Header>
                </Header>
                <CodeHead>
                    <![CDATA[
extern XCHAR [CONTROLID_NOINDEX]_Text[];
]]>
                </CodeHead>
            </ExternRamXCharArray>
        </TextDeclare>
        <MatrixTextDeclare>
            <ConstXcharArray>
                <![CDATA[
const XCHAR [CONTROLID]_Text[][] = [QTEXT]; // [TEXT]
]]>
            </ConstXcharArray>
            <RamXcharArray>
                <![CDATA[
XCHAR [CONTROLID]_Text[][[CHARMAX]] = [QTEXT]; // [TEXT]
]]>
            </RamXcharArray>
            <ExternXcharPointer>
                <![CDATA[
extern XCHAR *[CONTROLID_NOINDEX]_Text[];
]]>
            </ExternXcharPointer>
            <ExternRamXCharArray>
                <![CDATA[
extern XCHAR [CONTROLID_NOINDEX]_Text[][];
]]>
            </ExternRamXCharArray>
        </MatrixTextDeclare>
        <BitmapsDeclare>
            <PointerName>
                <![CDATA[
p[BITMAPNAME]
]]>
            </PointerName>
            <PointerInit>
                <![CDATA[
//[POINTERNAME]=(void *)&[BITMAP]; // Uncomment this line to initialize the bitmap pointer here, otherwise do it in your code before calling this CreateXXX()
]]>
            </PointerInit>
            <Bitmaps>
                <![CDATA[
extern void *[POINTERNAME]; // Pointer to bitmap [BITMAPNAME]
]]>
            </Bitmaps>
            <BitmapsGroup>
                <GroupStart>
                    <![CDATA[
[EMPTYLINE]
    // Picture Group [GROUPNAME]
    PICTURE * [GROUPNAME][] = {
]]>
                </GroupStart>
                <GroupItem>
                    <![CDATA[
    (void *) &[BITMAPNAME]
]]>
                </GroupItem>
                <GroupEnd>
                    <![CDATA[
};
]]>
                </GroupEnd>
                <GroupHeader>
                    <![CDATA[
    extern PICTURE * [GROUPNAME][];
    #define [GROUPNAME_UPPER]_NUMBITMAPS [GROUP_BITMAP_COUNT]
]]>
                </GroupHeader>
            </BitmapsGroup>
        </BitmapsDeclare>
        <FontsDeclare>
            <FontFilter>
                <Header>
                    <![CDATA[
#define [FONT]_FILTERTABLE_SIZE [FILTERTABLE_SIZE]
extern const UINT16 [FONT]_FilterTable[[FONT]_FILTERTABLE_SIZE];
]]>
                </Header>
                <CodeHead>
                    <![CDATA[
const UINT16 [FONT]_FilterTable[[FILTERTABLE_SIZE]] = {[FILTERTABLE]}; // [FILTERTABLE_CHARS]
]]>
                </CodeHead>
            </FontFilter>
            <FLASH_VGDD>
                <Header>
                    <![CDATA[
extern const FONT_FLASH [FONT]; // SIZE=[FONTSIZE] bytes
]]>
                </Header>
                <CodeHead>
                    <![CDATA[
extern const char L[FONT][] __attribute__((aligned(2)));
const FONT_FLASH [FONT] = {0, L[FONT]};
]]>
                </CodeHead>
                <Code>
                    <![CDATA[
[EMPTYLINE]
// [FONT]: [FONTDEF] - Size: [FONTSIZE] bytes - VGDD_FLASH Font definition
const char L[FONT][] __attribute__((aligned(2))) = {
[HEX_LINES]
};
// [FONT] - Size: [FONTSIZE] bytes - End of VGDD_FLASH Font definition
]]>
                </Code>
            </FLASH_VGDD>
            <FLASH>
                <Header>
                    <![CDATA[
extern const FONT_FLASH [FONT];
]]>
                </Header>
            </FLASH>
            <EXTERNAL>
                <Header>
                    <![CDATA[
extern const FONT_FLASH [FONT];
]]>
                </Header>
            </EXTERNAL>
            <BINFONT_ON_SDFAT>
                <CodeHead>
                    <![CDATA[
const FONT_ON_SD [FONT] = {BINFONT_ON_SDFAT, "[FONTSDFILENAME]"};
]]>
                </CodeHead>
            </BINFONT_ON_SDFAT>
        </FontsDeclare>
        <CreateSchemes>
            <Header>
                <![CDATA[
extern GOL_SCHEME* GOLScheme_[SCHEME_NAME];
void CreateScheme_[SCHEME_NAME](void);
]]>
            </Header>
            <CodeHead>
                <![CDATA[
GOL_SCHEME* GOLScheme_[SCHEME_NAME]=NULL;
]]>
            </CodeHead>
            <Code>
                <![CDATA[
void CreateScheme_[SCHEME_NAME](void) {
    if (GOLScheme_[SCHEME_NAME] == NULL) {
        GOLScheme_[SCHEME_NAME] = GOLCreateScheme();
        GOLScheme_[SCHEME_NAME]->Color0 = [COLOR0]; // [COLOR0_STRING]
        GOLScheme_[SCHEME_NAME]->Color1 = [COLOR1]; // [COLOR1_STRING]
        GOLScheme_[SCHEME_NAME]->ColorDisabled = [COLORDISABLED]; // [COLORDISABLED_STRING]
        GOLScheme_[SCHEME_NAME]->CommonBkColor = [COMMONBKCOLOR]; // [COMMONBKCOLOR_STRING]
        GOLScheme_[SCHEME_NAME]->EmbossDkColor = [EMBOSSDKCOLOR]; // [EMBOSSDKCOLOR_STRING]
        GOLScheme_[SCHEME_NAME]->EmbossLtColor = [EMBOSSLTCOLOR]; // [EMBOSSLTCOLOR_STRING]
        GOLScheme_[SCHEME_NAME]->TextColor0 = [TEXTCOLOR0]; // [TEXTCOLOR0_STRING]
        GOLScheme_[SCHEME_NAME]->TextColor1 = [TEXTCOLOR1]; // [TEXTCOLOR1_STRING]
        GOLScheme_[SCHEME_NAME]->TextColorDisabled = [TEXTCOLORDISABLED]; // [TEXTCOLORDISABLED_STRING]
        GOLScheme_[SCHEME_NAME]->pFont = (void*)&[FONT_NAME]; //

        #ifdef USE_GRADIENT
            GOLScheme_[SCHEME_NAME]->gradientScheme.gradientType=[GRADIENTTYPE];
            GOLScheme_[SCHEME_NAME]->gradientScheme.gradientStartColor=[GRADIENTSTARTCOLOR]; // [GRADIENTSTARTCOLOR_STRING]
            GOLScheme_[SCHEME_NAME]->gradientScheme.gradientEndColor=[GRADIENTENDCOLOR]; // [GRADIENTENDCOLOR_STRING]
            GOLScheme_[SCHEME_NAME]->gradientScheme.gradientLength=[GRADIENTLENGTH];
        #endif
    }
}
]]>
            </Code>
        </CreateSchemes>
        <EventHandling>
            <MsgCallBack>
                <Header>
                    <![CDATA[
WORD VGDD_[PROJECT_CLEAN_NAME]_MsgCallback(WORD objMsg, OBJ_HEADER *pObj, GOL_MSG *pMsg);
]]>
                </Header>
                <CodeHead>
                    <![CDATA[
#include "[PROJECTFILENAME_HELPERH]"
]]>
                </CodeHead>
                <Code>
                    <Head>
                        <![CDATA[
// ------------------------------------------------------------------------------------------------------------
// VGDD Automatic Event Handling - Events messages routine
// ------------------------------------------------------------------------------------------------------------
// The VGDD_[PROJECT_CLEAN_NAME]_MsgCallback function will take care of handling events generated by your widgets
// and will execute the code you specified in Event Editor for each widget. In order for it to compile and work,
// you have to manually put every needed variable and constant definition into the [PROJECTFILENAME_HELPERH]
// header file, obviously only the first time.
[EMPTYLINE]
// To obtain Automatic Event Handling, you will also have to insert a call to VGDD_[PROJECT_CLEAN_NAME]_MsgCallback
// into your main "standard" GOLMsgCallback function (see Microchip's demos) passing all three parameters:
// return(VGDD_[PROJECT_CLEAN_NAME]_MsgCallback(objMsg, pObj, pMsg));
[EMPTYLINE]
WORD VGDD_[PROJECT_CLEAN_NAME]_MsgCallback(WORD objMsg, OBJ_HEADER *pObj, GOL_MSG *pMsg) {
WORD objId;
objId = GetObjID(pObj);
switch (screenState) {
]]>
                    </Head>
                    <ScreenHead>
                        <![CDATA[
    case DISPLAY_[SCREEN_UPPERNAME]:
    switch (objId) {
]]>
                    </ScreenHead>
                    <ControlHead>
                        <![CDATA[
        case ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]:
]]>
                    </ControlHead>
                    <Event>
                        <![CDATA[
            if (objMsg == [EVENTMSG]) {
                [CONTROLEVENTCODE]
            }
]]>
                    </Event>
                    <ControlFoot>
                        <![CDATA[
            break;
            [EMPTYLINE]
]]>
                    </ControlFoot>
                    <ScreenFoot>
                        <![CDATA[
        default:
            break;
    } // End switch (objId) for DISPLAY_[SCREEN_UPPERNAME]
    break;]]>
                    </ScreenFoot>
                    <NormalScreensFoot>
                        <![CDATA[
        default:
            break;
    } // End switch (screenState)
]]>
                    </NormalScreensFoot>
                    <MasterScreenHead>
                        <![CDATA[
    [EMPTYLINE]
    switch (objId) { // MasterScreens
]]>
                    </MasterScreenHead>
                    <MasterScreenFoot>
                        <![CDATA[
    } // End switch (objId) for MasterScreens
]]>
                    </MasterScreenFoot>
                    <Foot>
                        <![CDATA[
    return (1);
} // End VGDD_[PROJECT_CLEAN_NAME]_MsgCallback
[EMPTYLINE]
]]>
                    </Foot>
                </Code>
            </MsgCallBack>
            <DrawCallBack>
                <Header>
                    <![CDATA[
WORD VGDD_[PROJECT_CLEAN_NAME]_DrawCallback(void);
]]>
                </Header>
                <CodeHead>
                </CodeHead>
                <Code>
                    <Head>
                        <![CDATA[
// ------------------------------------------------------------------------------------------------------------
// VGDD Automatic Event Handling - Draw Callback routine
// ------------------------------------------------------------------------------------------------------------
// The VGDD_[PROJECT_CLEAN_NAME]_DrawCallback function will take care of calling the CreateXXX() subroutines in order
// to draw widgets defined in the screen, according to the current screenState variable.
// In order for it to work, you have to insert a call to VGDD_[PROJECT_CLEAN_NAME]_DrawCallback into your main
// "standard" GOLDrawCallback function (see Microchip's demos) with no parameters:
// return(VGDD_[PROJECT_CLEAN_NAME]_DrawCallback());
[EMPTYLINE]
WORD VGDD_[PROJECT_CLEAN_NAME]_DrawCallback(void) {
    switch (screenState) {
]]>
                    </Head>
                    <ScreenHead>
                        <![CDATA[
        [EMPTYLINE]
        case CREATE_[SCREEN_UPPERNAME]: {
            [SCREEN_BEFORE_CREATE]
            Create[SCREEN_NAME]();
            [SCREEN_AFTER_CREATE]
            screenState = UPDATE_[SCREEN_UPPERNAME];
            break;
        }
        case UPDATE_[SCREEN_UPPERNAME]: {
            [SCREEN_UPDATE_CODE]
            screenState = DISPLAY_[SCREEN_UPPERNAME];
            break;
        }
        case DISPLAY_[SCREEN_UPPERNAME]: {
            [SCREEN_DISPLAY_CODE]
            break;
        }
]]>
                    </ScreenHead>
                    <Foot>
                        <![CDATA[
        default:
            break;
    } // End switch (screenState)
    return (1);
} // End VGDD_[PROJECT_CLEAN_NAME]_DrawCallback
[EMPTYLINE]
]]>
                    </Foot>
                </Code>
            </DrawCallBack>
        </EventHandling>
        <ResourceAllocation>
            Module           HeapPIC24  HeapPIC32   HeapItem   RAMPIC24   RAMPIC32   ROMPIC24   ROMPIC32
            PrimitivesLayer          0          0          0         68         53       3375       8868
            GOL                     20         24          0         32         28       2076       5400
            Button                  28         44          0          8         12       1002       2748
            Chart                   48         76          0         94        104      11427      26364
            CheckBox                22         36          0          2          4        894       2320
            RoundDial               30         40          0          8         12       1065       3228
            DigitalMeter            28         56          0          2          4       1125       2202
            EditBox                 26         40          0          2          4        822       2332
            GroupBox                24         36          0          8         12        903       2164
            ListBox                 28         44         12          6         12       1809       2580
            Meter                   52         68          0         36         40       2778       6788
            Picture                 22         36          0         10         12        645       1512
            ProgressBar             24         36          0         12         16       1050       2452
            RadioButton             26         44          0         14         20        993       2632
            Slider                  32         44          0         20         24       2094       5720
            StaticText              22         36          0          8         12        747       1884
            TextEntry               34         52         24         22         28       2484       6376
            Window                  24         40          0          2          4        804       1996

            SuperGauge             108        120          0         28         28       7896      11492
            Indicator               34         48          0         10         12       1076       2832
            Disp7Seg                40         56          0          6          6        768       1956
            VuMeter                 74         88          0          0          0       2732       6820
            BarGraph                64         78          0          0          0       2226       5276
            MsgBox                  54         82          0         14         14       2844       7668
            TextEntryEx              0          0          0          0          0          0      10624
            StaticTextEx            22         36          0          8         12        747       1884
        </ResourceAllocation>
        <GOLFree>
            <![CDATA[
    GOLFree();
]]>
        </GOLFree>
    </ProjectTemplates>
    <ScreenTemplates>
        <Create>
            <Header>
                <![CDATA[
void Create[SCREEN_NAME](void);
]]>
            </Header>
            <CodeHead>
            </CodeHead>
            <Code>
                <Normal>
                    <![CDATA[
[EMPTYLINE]
void Create[SCREEN_NAME](void) {
    [GOLFREE]
    SetColor([SCREEN_BACKCOLOR]); // [SCREEN_BACKCOLOR_STRING]
    ClearDevice();
    #if defined(USE_TRANSPARENT_COLOR)
        TransparentColorEnable([TRANSPARENT_COLOUR]); // [TRANSPARENT_COLOUR_STRING]
    #endif
]]>
                </Normal>
                <Overlay>
                    <![CDATA[
[EMPTYLINE]
void Create[SCREEN_NAME](void) {
    [GOLFREE]
    #if defined(USE_TRANSPARENT_COLOR)
        TransparentColorEnable([TRANSPARENT_COLOUR]); // [TRANSPARENT_COLOUR_STRING]
    #endif
]]>
                </Overlay>
                <MasterScreen>
                    <![CDATA[
[EMPTYLINE]
void Create[SCREEN_NAME](void) {
]]>
                </MasterScreen>
                <NormalWithMasterScreen>
                    <![CDATA[
[EMPTYLINE]
void Create[SCREEN_NAME](void) {
    [GOLFREE]
    SetColor([SCREEN_BACKCOLOR]); // [SCREEN_BACKCOLOR_STRING]
    ClearDevice();
    #if defined(USE_TRANSPARENT_COLOR)
        TransparentColorEnable([TRANSPARENT_COLOUR]); // [TRANSPARENT_COLOUR_STRING]
    #endif
    [CREATE_MASTERSCREENS]
]]>
                </NormalWithMasterScreen>
                <CreateMasterScreens>
                    <![CDATA[
    Create[MASTERSCREEN_NAME]();
]]>
                </CreateMasterScreens>
            </Code>
        </Create>
        <CreateSchemes>
            <Code>
                <![CDATA[
    CreateScheme_[SCHEME_NAME]();
]]>
            </Code>
        </CreateSchemes>
        <ClosingBlock>
            <Header>
            </Header>
            <Code>
                <![CDATA[
} // End of Create[SCREEN_NAME]
[EMPTYLINE]
]]>
            </Code>
        </ClosingBlock>
    </ScreenTemplates>
    <ControlsTemplates>
        <Screen>
            <Events>
                <Event Name="SCREEN_BEFORE_CREATE" Description="Executes before screen creation" PlayerEvent="MOUSE_DOWN" />
                <Event Name="SCREEN_AFTER_CREATE" Description="Executes before screen is displayed" PlayerEvent="MOUSE_DOWN" />
                <Event Name="SCREEN_UPDATE" Description="Executes when screenState is set to UPDATE by code" PlayerEvent="MOUSE_DOWN" />
                <Event Name="SCREEN_DISPLAY" Description="Executes continuously while screen is displayed. Use this to do timed actions in code." PlayerEvent="MOUSE_DOWN" />
            </Events>
            <Actions>
                <Action Name="Go to Screen" Code="screenState=CREATE_[SCREEN_UPPERNAME];[NEWLINE]" />
                <!--<Action Name="Timed Action" Code="// Use this version only when TCP/IP stack is added to the project[NEWLINE]static DWORD Tick_[SCREEN_NAME];[NEWLINE]if (TickGet() - Tick_[SCREEN_NAME] > TICK_SECOND * 2) {[NEWLINE]    Tick_[SCREEN_NAME] = TickGet();[NEWLINE]    // Do something[NEWLINE]}" />-->
                <Action Name="Timed Action" Code="static DWORD Tick_[SCREEN_NAME];[NEWLINE]if (tick - Tick_[SCREEN_NAME] > 100) {[NEWLINE]    Tick_[SCREEN_NAME] = tick;[NEWLINE]    // Do something[NEWLINE]}" />
                <Action Name="Turn Display Off" Code="DisplayBacklightOff();" />
                <Action Name="Turn Display On" Code="DisplayBacklightOn();" />
            </Actions>
        </Screen>
        <Button>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/Button.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/Button.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_BUTTON_MULTI_LINE
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    BUTTON *p[CONTROLID];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    [BITMAP_POINTER_INIT]
    p[CONTROLID] = BtnCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[RADIUS],[STATE],[BITMAP],(XCHAR*)[WIDGETTEXT],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="BTN_DRAW" False="BTN_DISABLED" />
                <Hidden False="BTN_DRAW" True="BTN_HIDE" />
                <HorizAlign Left="BTN_TEXTLEFT" Right="BTN_TEXTRIGHT" Center="BTN_DRAW" />
                <VertAlign Top="BTN_TEXTTOP" Bottom="BTN_TEXTBOTTOM" Center="BTN_DRAW" />
                <Pressed True="BTN_PRESSED" False="BTN_DRAW" />
                <NoPanel True="BTN_NOPANEL" False="BTN_DRAW" />
                <TwoTone True="BTN_TWOTONE" False="BTN_DRAW" />
                <HasFocus True="BTN_FOCUSED" False="BTN_DRAW" />
                <Toggle True="BTN_TOGGLE" False="BTN_DRAW" />
            </State>
            <Events>
                <Event Name="BTN_MSG_PRESSED" LegacyName="GFX_GOL_BUTTON_ACTION_PRESSED" Description="Button pressed" PlayerEvent="MOUSE_DOWN" />
                <Event Name="BTN_MSG_STILLPRESSED" LegacyName="GFX_GOL_BUTTON_ACTION_STILLPRESSED" Description="Button is continuously pressed" PlayerEvent="MOUSE_DOWN" />
                <Event Name="BTN_MSG_RELEASED" LegacyName="GFX_GOL_BUTTON_ACTION_RELEASED" Description="Button released" PlayerEvent="MOUSE_UP" />
                <Event Name="BTN_MSG_CANCELPRESS" LegacyName="GFX_GOL_BUTTON_ACTION_CANCELPRESS" Description="Button released with button press canceled" PlayerEvent="MOUSE_LEAVE" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set Button Text"
                                Code="BtnSetText((BUTTON *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (XCHAR *) $Quoted string constant or variable:|&quot;New text&quot;$);[NEWLINE]"
                                Help="Sets the string used for the object."/>
                <Action Name="Get Button Text"
                                Code="XCHAR *pText;
pText = BtnGetText((BUTTON *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Returns pointer to the text string being used"/>
                <Action Name="Set Button Bitmap"
                                Code="BtnSetBitmap((BUTTON *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (void *)&amp;%BITMAP%);[NEWLINE]"
                                Help="Sets the bitmap used in the object"/>
                <Action Name="Get Button Bitmap" Code="BITMAP_FLASH *pUsedBitmap;
pUsedbitmap = BtnGetBitmap((BUTTON *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Returns the pointer to the current bitmap used."/>
                <Action Name="Hide Button" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), BTN_HIDE);[NEWLINE]" />
                <Action Name="Disable Button" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), BTN_DISABLED);[NEWLINE]" />
                <Action Name="Enable Button" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), BTN_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update Button" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), BTN_DRAW);[NEWLINE]" />
                <Action Name="Use Text Buffer name" Code="[CONTROLID_NOINDEX][CONTROLID_INDEX]_Text" />
                <Action Name="=== Using pointer ===" Code="" />
                <Action Name="Create pointer var (mandatory)" Code="BUTTON *pbtn[CONTROLID_NOINDEX][CONTROLID_INDEX]=(BUTTON *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]" />
                <Action Name="Set Button Text(2)"
                                Code="BtnSetText(pbtn[CONTROLID_NOINDEX][CONTROLID_INDEX], (XCHAR *) $Quoted string constant or variable:|&quot;New text&quot;$);[NEWLINE]"
                                Help="Sets the string that will be used for the object"/>
                <Action Name="Get Button Text(2)"
                                Code="XCHAR *pText=BtnGetText(pbtn[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]"
                                Help="Returns the pointer to the text string used"/>
                <Action Name="Set Button Bitmap(2)"
                                Code="BtnSetBitmap(pbtn[CONTROLID_NOINDEX][CONTROLID_INDEX], (void *)&amp;%BITMAP%);[NEWLINE]"
                                Help="Sets the bitmap used in the object"/>
                <Action Name="Get Button Bitmap(2)" Code="BITMAP_FLASH *pUsedBitmap = BtnGetBitmap(pbtn[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]"
                                Help="Returns the pointer to the current bitmap used."/>
                <Action Name="Hide Button(2)" Code="SetState(pbtn[CONTROLID_NOINDEX][CONTROLID_INDEX], BTN_HIDE);[NEWLINE]" />
                <Action Name="Disable Button(2)" Code="SetState(pbtn[CONTROLID_NOINDEX][CONTROLID_INDEX], BTN_DISABLED);[NEWLINE]" />
                <Action Name="Enable Button(2)" Code="ClrState(pbtn[CONTROLID_NOINDEX][CONTROLID_INDEX], BTN_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update Button(2)" Code="SetState(pbtn[CONTROLID_NOINDEX][CONTROLID_INDEX], BTN_DRAW);[NEWLINE]" />
            </Actions>
        </Button>
        <StaticText>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/StaticText.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/StaticText.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_STATICTEXT
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    STATICTEXT *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = StCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],(XCHAR*)[WIDGETTEXT],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="ST_DRAW" False="ST_DRAW|ST_DISABLED" />
                <Hidden False="ST_DRAW" True="ST_HIDE" />
                <HorizAlign Left="ST_DRAW" Right="ST_RIGHT_ALIGN" Center="ST_CENTER_ALIGN" />
                <Frame Enabled="ST_FRAME" Disabled="ST_DRAW" />
            </State>
            <Events>
                <Event Name="ST_MSG_SELECTED" LegacyName="GFX_GOL_STATICTEXT_ACTION_SELECTED" Description="Static Text selected" PlayerEvent="MOUSE_DOWN" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set StaticText Text"
                                Code="StSetText((STATICTEXT *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (XCHAR *) $Quoted string constant or variable:|&quot;New text&quot;$);[NEWLINE]"
                                Help="Sets the string that will be used for the object"/>
                <Action Name="Get StaticText Text"
                                Code="XCHAR *pText=((STATICTEXT *)(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX])))->pText;[NEWLINE]"
                                Help="Returns the pointer to the text string used"/>
                <Action Name="Hide StaticText" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), ST_HIDE);[NEWLINE]" />
                <Action Name="Disable StaticText" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), ST_DISABLED);[NEWLINE]" />
                <Action Name="Enable StaticText" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), ST_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update StaticText" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), ST_DRAW);[NEWLINE]" />
                <Action Name="Use Text Buffer name" Code="[CONTROLID_NOINDEX][CONTROLID_INDEX]_Text" />
                <Action Name="=== Using pointer ===" Code="" />
                <Action Name="Create pointer var (mandatory)" Code="STATICTEXT *pst[CONTROLID_NOINDEX][CONTROLID_INDEX]=(STATICTEXT *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]" />
                <Action Name="Set StaticText Text(2)"
                                Code="StSetText(pst[CONTROLID_NOINDEX][CONTROLID_INDEX], (XCHAR *) $Quoted string constant or variable:|&quot;New text&quot;$);[NEWLINE]"
                                Help="Sets the string that will be used for the object"/>
                <Action Name="Get StaticText Text(2)"
                                Code="XCHAR *pText=pst[CONTROLID_NOINDEX][CONTROLID_INDEX]->pText;[NEWLINE]"
                                Help="Returns the pointer to the text string used"/>
                <Action Name="Hide StaticText(2)" Code="SetState(pst[CONTROLID_NOINDEX][CONTROLID_INDEX], ST_HIDE);[NEWLINE]" />
                <Action Name="Disable StaticText(2)" Code="SetState(pst[CONTROLID_NOINDEX][CONTROLID_INDEX], ST_DISABLED);[NEWLINE]" />
                <Action Name="Enable StaticText(2)" Code="ClrState(pst[CONTROLID_NOINDEX][CONTROLID_INDEX], ST_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update StaticText(2)" Code="SetState(pst[CONTROLID_NOINDEX][CONTROLID_INDEX], ST_DRAW);[NEWLINE]" />
            </Actions>
        </StaticText>
        <CheckBox>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/CheckBox.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/CheckBox.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_CHECKBOX
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]]]>
            </Header>
            <Constructor>
                <![CDATA[
    CHECKBOX *p[CONTROLID];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID] = CbCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],(XCHAR*)[WIDGETTEXT],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="CB_DRAW" False="CB_DRAW|CB_DISABLED" />
                <Hidden False="CB_DRAW" True="CB_HIDE" />
                <Checked True="CB_CHECKED" False="CB_DRAW" />
            </State>
            <Events>
                <Event Name="CB_MSG_CHECKED" LegacyName="GFX_GOL_CHECKBOX_ACTION_CHECKED" Description="CheckBox checked" PlayerEvent="CHECKED" />
                <Event Name="CB_MSG_UNCHECKED" LegacyName="GFX_GOL_CHECKBOX_ACTION_UNCHECKED" Description="CheckBox un-checked" PlayerEvent="UNCHECKED" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set CheckBox Text"
                                Code="CbSetText((CHECKBOX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (XCHAR *) $Quoted string constant or variable:|&quot;New text&quot;$);[NEWLINE]"
                                Help="This function sets the text that will be used"/>
                <Action Name="Get CheckBox Text" Code="XCHAR *pText;
pText=CbGetText((CHECKBOX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Returns the location of the text used for the check box"/>
                <Action Name="Set CheckBox State to ON (checked)" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), CB_CHECKED | CB_DRAW_CHECK);[NEWLINE]" />
                <Action Name="Set CheckBox State to OFF (unchecked)" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), CB_CHECKED);[NEWLINE]SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), CB_DRAW_CHECK);[NEWLINE]" />
                <Action Name="Hide CheckBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), CB_HIDE);[NEWLINE]" />
                <Action Name="Disable CheckBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), CB_DISABLED);[NEWLINE]" />
                <Action Name="Enable CheckBox" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), CB_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update CheckBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), CB_DRAW);[NEWLINE]" />
                <Action Name="Use Text Buffer name" Code="[CONTROLID_NOINDEX][CONTROLID_INDEX]_Text" />
                <Action Name="=== Using pointer ===" Code="" />
                <Action Name="Create pointer var (mandatory)" Code="CHECKBOX *chk[CONTROLID_NOINDEX][CONTROLID_INDEX]=(CHECKBOX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]" />
                <Action Name="Set CheckBox Text(2)"
                                Code="CbSetText(pst[CONTROLID_NOINDEX][CONTROLID_INDEX], (XCHAR *) $Quoted string constant or variable:|&quot;New text&quot;$);[NEWLINE]"
                                Help="Sets the string that will be used for the object"/>
                <Action Name="Get CheckBox Text(2)"
                                Code="XCHAR *pText=CbGetText(chk[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]"
                                Help="Returns the pointer to the text string used"/>
                <Action Name="Set CheckBox State to ON (checked)(2)" Code="SetState(chk[CONTROLID_NOINDEX][CONTROLID_INDEX], CB_CHECKED | CB_DRAW_CHECK);[NEWLINE]" />
                <Action Name="Set CheckBox State to OFF (unchecked)(2)" Code="ClrState(chk[CONTROLID_NOINDEX][CONTROLID_INDEX], CB_CHECKED);[NEWLINE]SetState(chk[CONTROLID_NOINDEX][CONTROLID_INDEX], CB_DRAW_CHECK);[NEWLINE]" />
                <Action Name="Hide CheckBox(2)" Code="SetState(chk[CONTROLID_NOINDEX][CONTROLID_INDEX], CB_HIDE);[NEWLINE]" />
                <Action Name="Disable CheckBox(2)" Code="SetState(chk[CONTROLID_NOINDEX][CONTROLID_INDEX], CB_DISABLED);[NEWLINE]" />
                <Action Name="Enable CheckBox(2)" Code="ClrState(chk[CONTROLID_NOINDEX][CONTROLID_INDEX], CB_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update CheckBox(2)" Code="SetState(chk[CONTROLID_NOINDEX][CONTROLID_INDEX], CB_DRAW);[NEWLINE]" />
            </Actions>
        </CheckBox>
        <EditBox>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/EditBox.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/EditBox.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_EDITBOX
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    EDITBOX *p[CONTROLID];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID] = EbCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],(XCHAR*)[CONTROLID]_Text,[CHARMAX],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="EB_DRAW" False="EB_DRAW|EB_DISABLED" />
                <Hidden False="EB_DRAW" True="EB_HIDE" />
                <TextAlign Left="EB_DRAW" Right="EB_RIGHT_ALIGN" Center="EB_CENTER_ALIGN" />
                <Caret True="EB_CARET" False="EB_DRAW" />
            </State>
            <Events>
                <Event Name="EB_MSG_CHAR" LegacyName="GFX_GOL_EDITBOX_ACTION_ADD_CHAR" Description="EditBox character inserted" />
                <Event Name="EB_MSG_DEL" LegacyName="GFX_GOL_EDITBOX_ACTION_DEL_CHAR" Description="EditBox character removed" />
                <Event Name="EB_MSG_TOUCHSCREEN" LegacyName="GFX_GOL_EDITBOX_ACTION_TOUCHSCREEN" Description="EditBox touched" PlayerEvent="MOUSE_DOWN" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Use Text Buffer name" Code="[CONTROLID]_Text" />
                <Action Name="Set EditBox Text"
                                Code="EbSetText((EDITBOX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (XCHAR *) $Quoted string constant or variable:|&quot;New text&quot;$);[NEWLINE]"
                                Help="Sets the text to be used for the object"/>
                <Action Name="Add a character at the end"
                                Code="EbAddChar((EDITBOX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (XCHAR) $Quoted char constant or variable:|'c'$);[NEWLINE]"
                                Help="Inserts a character at the end of the text used by the object"/>
                <Action Name="Delete last character"
                                Code="EbDeleteChar((EDITBOX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Removes a character at the end of the text used by the object"/>
                <Action Name="Hide EditBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), EB_HIDE);[NEWLINE]" />
                <Action Name="Disable EditBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), EB_DISABLED);[NEWLINE]" />
                <Action Name="Enable EditBox" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), EB_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update EditBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), EB_DRAW);[NEWLINE]" />
                <Action Name="Edit text using EditNumUpDown" Code="if (pMsg->uiEvent == EVENT_RELEASE) {
                            EditNumIdActive = ID_[CONTROLID_NOINDEX][CONTROLID_INDEX];
                            EditNumPun = (XCHAR *) &amp;[CONTROLID]_Text;
                            EditTextMode = NUMERICUPDOWN;
                        	EditNumMin=0;
                        	EditNumMax=255;
                        	prevState = screenState;
                            screenState = CREATE_EDITNUM;
                        }" />
            </Actions>
        </EditBox>
        <RadioButton>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/RadioButton.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/RadioButton.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_RADIOBUTTON
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    RADIOBUTTON *p[CONTROLID];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID] = RbCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],(XCHAR*)[WIDGETTEXT],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="RB_DRAW" False="RB_DRAW|RB_DISABLED" />
                <Hidden False="RB_DRAW" True="RB_HIDE" />
                <Checked True="RB_CHECKED" False="RB_DRAW" />
                <FirstInGroup True="RB_GROUP" False="RB_DRAW" />
            </State>
            <Events>
                <Event Name="RB_MSG_CHECKED" LegacyName="GFX_GOL_RADIOBUTTON_ACTION_CHECKED" Description="RadioButton checked" PlayerEvent="CHECKEDCHANGE" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set RadioButton Text"
                                Code="RbSetText((RADIOBUTTON *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (XCHAR *) $Quoted string constant or variable:|&quot;New text&quot;$);[NEWLINE]"
                                Help="Sets the string used for the object"/>
                <Action Name="Get RadioButton Text"
                                Code="XCHAR *pText;
						pText=RbGetText((RADIOBUTTON *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Returns pointer to the text string being used"/>
                <Action Name="Set RadioButton State to ON (checked)"
                                Code="RbSetCheck((RADIOBUTTON *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]),ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]"
                                Help="This function sets the Radio Button to its checked state."/>
                <Action Name="Hide RadioButton" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), RB_HIDE);[NEWLINE]" />
                <Action Name="Disable RadioButton" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), RB_DISABLED);[NEWLINE]" />
                <Action Name="Enable RadioButton" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), RB_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update RadioButton" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), RB_DRAW);[NEWLINE]" />
                <Action Name="Get ID of the checked button in group"
                                Code="SHORT ID;
						ID=RbGetCheck((RADIOBUTTON *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX])"
                                Help="Returns the ID of the selected button in the group. It returns -1 if there is no object checked"/>
            </Actions>
        </RadioButton>
        <Window>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/Window.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/Window.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_WINDOW
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    WINDOW *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    [BITMAP_POINTER_INIT]
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = WndCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],[BITMAP],(XCHAR*)[WIDGETTEXT],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="WND_DRAW" False="WND_DRAW|WND_DISABLED" />
                <Hidden False="WND_DRAW" True="WND_HIDE" />
                <TitleAlign Left="WND_DRAW" Center="WND_TITLECENTER" Right="WND_DRAW"/>
            </State>
            <Events>
                <Event Name="WND_MSG_CLIENT" LegacyName="GFX_GOL_WINDOW_ACTION_CLIENT" Description="Window client area selected" />
                <Event Name="WND_MSG_TITLE" LegacyName="GFX_GOL_WINDOW_ACTION_TITLE" Description="Window title bar selected" PlayerEvent="MOUSE_DOWN" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set Window Text"
                                Code="WndSetText((WINDOW *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (XCHAR *) $Quoted string constant or variable:|&quot;New text&quot;$);[NEWLINE]"
                                Help="Sets the string used for the title bar"/>
                <Action Name="Get Window Text"
                                Code="XCAR *pText;
						pText=WndGetText((WINDOW *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Returns the address of the current text string used for the title bar"/>
                <Action Name="Hide Window" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), WND_HIDE);[NEWLINE]" />
                <Action Name="Show/Update Window" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), WND_DRAW);[NEWLINE]" />
            </Actions>
        </Window>
        <GroupBox>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/GroupBox.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/GroupBox.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_GROUPBOX
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    GROUPBOX *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = GbCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],(XCHAR*)[WIDGETTEXT],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="GB_DRAW" False="GB_DRAW|GB_DISABLED" />
                <Hidden False="GB_DRAW" True="GB_HIDE" />
                <HorizAlign Left="GB_DRAW" Right="GB_RIGHT_ALIGN" Center="GB_CENTER_ALIGN" />
            </State>
            <Events>
                <Event Name="GB_MSG_SELECTED" LegacyName="GFX_GOL_GROUPBOX_ACTION_SELECTED" Description="GroupBox selected" PlayerEvent="MOUSE_DOWN" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set GroupBox Text"
                                Code="GbSetText((GROUPBOX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (XCHAR *) $Quoted string constant or variable:|&quot;New text&quot;$);[NEWLINE]"
                                Help="Sets the string used for the object"/>
                <Action Name="Get GroupBox Text"
                                Code="XCHAR *pText;
						pText=GbGetText((GROUPBOX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Returns pointer to the text string being used"/>
                <Action Name="Hide GroupBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), GB_HIDE);[NEWLINE]" />
                <Action Name="Disable GroupBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), GB_DISABLED);[NEWLINE]" />
                <Action Name="Enable GroupBox" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), GB_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update GroupBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), GB_DRAW);[NEWLINE]" />
                <Action Name="Use Text Buffer name" Code="[CONTROLID_NOINDEX][CONTROLID_INDEX]_Text" />
            </Actions>
        </GroupBox>
        <ListBox>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/ListBox.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/ListBox.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_LISTBOX
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    LISTBOX *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = LbCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],(XCHAR*)[CONTROLID_NOINDEX]_Text[CONTROLID_INDEXPAR],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="LB_DRAW" False="LB_DRAW|LB_DISABLED" />
                <Hidden False="LB_DRAW" True="LB_HIDE" />
                <HorizAlign Left="LB_DRAW" Right="LB_RIGHT_ALIGN" Center="LB_CENTER_ALIGN" />
                <SingleSel True="LB_SINGLE_SEL" False="LB_DRAW" />
            </State>
            <Events>
                <Event Name="LB_MSG_SEL" LegacyName="GFX_GOL_LISTBOX_ACTION_SELECTED" Description="ListBox item selected" PlayerEvent="MOUSE_DOWN" />
                <Event Name="LB_MSG_MOVE" LegacyName="GFX_GOL_LISTBOX_ACTION_MOVE" Description="ListBox item moved" />
                <Event Name="LB_MSG_TOUCHSCREEN" LegacyName="GFX_GOL_LISTBOX_ACTION_TOUCHSCREEN" Description="ListBox touchscreen selected" />
            </Events>
            <Actions>
                <!-- TODO All Listbox Actions (a LOT!) -->
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Hide ListBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), LB_HIDE);[NEWLINE]" />
                <Action Name="Disable ListBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), LB_DISABLED);[NEWLINE]" />
                <Action Name="Enable ListBox" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), LB_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update ListBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), LB_DRAW);[NEWLINE]" />
                <Action Name="Use Text Buffer name" Code="[CONTROLID_NOINDEX][CONTROLID_INDEX]_Text" />
                <Action Name="=== Using pointer ===" Code="" />
                <Action Name="Create pointer var (mandatory)" Code="LISTBOX *pLb[CONTROLID_NOINDEX][CONTROLID_INDEX]=(LISTBOX *) GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]" />
                <Action Name="Append item" Code="LbAddItem(pLb[CONTROLID_NOINDEX][CONTROLID_INDEX], NULL, (XCHAR *) $Quoted string constant or variable:|&quot;New item&quot;$, NULL, LB_STS_REDRAW, 0);[NEWLINE]"
                        Help="Adds a new item to the Listbox"/>
                <Action Name="Get selected item" Code="LISTITEM *pSelItem=LbGetSel(pLb[CONTROLID_NOINDEX][CONTROLID_INDEX], NULL);[NEWLINE]"
                        Help="Get selected item in the Listbox (text and data)"/>
                <Action Name="Get selected item's text" Code="XCHAR *pSelItemText=LbGetSel(pLb[CONTROLID_NOINDEX][CONTROLID_INDEX], NULL)->pText;[NEWLINE]"
                        Help="Get text of selected item"/>
                <Action Name="Get selected item's data" Code="WORD SelItemData=LbGetSel(pLb[CONTROLID_NOINDEX][CONTROLID_INDEX], NULL)->data;[NEWLINE]"
                        Help="Get data from selected item"/>
            </Actions>
        </ListBox>
        <Picture>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/Picture.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/Picture.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_PICTURE
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    PICTURE *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    [BITMAP_POINTER_INIT]
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = PictCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],[SCALE],[BITMAP],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="PICT_DRAW" False="PICT_DRAW|PICT_DISABLED" />
                <Hidden False="PICT_DRAW" True="PICT_HIDE" />
                <Frame Enabled="PICT_FRAME" Disabled="PICT_DRAW" />
            </State>
            <Events>
                <Event Name="PICT_MSG_SELECTED" LegacyName="GFX_GOL_PICTURECONTROL_ACTION_SELECTED" Description="Picture selected" PlayerEvent="MOUSE_DOWN" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set Picture Bitmap"
                                Code="PictSetBitmap((PICTURE *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (void *)&amp;%BITMAP%); // Replace %BITMAP% with bitmap name as found in the Bitmap chooser[NEWLINE]"
                                Help="Sets the bitmap used in the object"/>
                <Action Name="Get Picture Bitmap"
                                Code="PICTURE *pBitmap;
						pBitmap=PictGetBitmap((PICTURE *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Returns the pointer to the bitmap used in the object"/>
                <Action Name="Get Picture Scale factor"
                                Code="char Scale;
						Scale=PictGetScale((PICTURE *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Returns the current scale factor used to display the bitmap"/>
                <Action Name="Set Picture Scale factor"
                                Code="PictSetScale((PICTURE *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (char) $New scale (valid values are 1 or 2):|2$);[NEWLINE]"
                                Help="Sets the scale factor used to render the bitmap used in the object"/>
                <Action Name="Hide Picture" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), PICT_HIDE);[NEWLINE]" />
                <Action Name="Disable Picture" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), PICT_DISABLED);[NEWLINE]" />
                <Action Name="Enable Picture" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), PICT_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update Picture" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), PICT_DRAW);[NEWLINE]" />
            </Actions>
        </Picture>
        <ProgressBar>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/ProgressBar.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/ProgressBar.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_PROGRESSBAR
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    PROGRESSBAR *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = PbCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],[POS],[RANGE],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="PB_DRAW" False="PB_DRAW|PB_DISABLED" />
                <Hidden False="PB_DRAW" True="PB_HIDE" />
                <Orientation Horizontal="PB_DRAW" Vertical="PB_VERTICAL" />
                <ShowPercentage True="PB_DRAW" False="PB_NOPROGRESS" />
            </State>
            <Events>
                <Event Name="PB_MSG_SELECTED" LegacyName="GFX_GOL_PROGRESSBAR_ACTION_SELECTED" Description="ProgressBar selected" PlayerEvent="MOUSE_DOWN" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Get ProgressBar Position"
                                Code="((PROGRESSBAR *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]))->pos"
                                Help="Returns the current progress bar position"/>
                <Action Name="Get ProgressBar Position and put it in a variable"
                                Code="$Variable name where to store position:|myPos$ = ((PROGRESSBAR *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]))->pos; [NEWLINE]"
                                Help="Sets a variable with the current progress bar position"/>
                <Action Name="Set ProgressBar Position"
                                Code="PbSetPos((PROGRESSBAR *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), $Numeric constant or variable:|50$);[NEWLINE]"
                                Help="Sets the position of the progress bar. Position should be in the given range inclusive"/>
                <Action Name="Redraw Bar"
                                Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), PB_DRAW_BAR);[NEWLINE]"
                                Help="Redraws the Bar only. Use after having changed ProgressBar Position"/>
                <Action Name="Get ProgressBar Range"
                                Code="$Variable name where to store range:|myRange$ = PbGetRange((PROGRESSBAR *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Returns the current range of the progress bar"/>
                <Action Name="Set ProgressBar Range"
                                Code="PbSetRange((PROGRESSBAR *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), $Numeric constant or variable:|100$);[NEWLINE]"
                                Help="Sets the range of the progress bar. Calling this function also resets the position equal to the new range value"/>
                <Action Name="Hide ProgressBar" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), PB_HIDE);[NEWLINE]" />
                <Action Name="Disable ProgressBar" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), PB_DISABLED);[NEWLINE]" />
                <Action Name="Enable ProgressBar" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), PB_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update ProgressBar" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), PB_DRAW);[NEWLINE]" />
                <Action Name="=== Using pointer ===" Code="" />
                <Action Name="Create pointer var (mandatory)" Code="PROGRESSBAR *pPb[CONTROLID_NOINDEX][CONTROLID_INDEX]=(PROGRESSBAR *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]" />
                <Action Name="Get ProgressBar Position (2)"
                                Code="pPb[CONTROLID_NOINDEX][CONTROLID_INDEX]->pos"
                                Help="Returns the current progress bar position"/>
                <Action Name="Get ProgressBar Position and put it in a variable (2)"
                                Code="$Variable name where to store position:|myPos$ = pPb[CONTROLID_NOINDEX][CONTROLID_INDEX]->pos; [NEWLINE]"
                                Help="Sets a variable with the current progress bar position"/>
                <Action Name="Set ProgressBar Position (2)"
                                Code="PbSetPos(pPb[CONTROLID_NOINDEX][CONTROLID_INDEX]), $Numeric constant or variable:|50$);[NEWLINE]"
                                Help="Sets the position of the progress bar. Position should be in the given range inclusive"/>
                <Action Name="Redraw Bar (2)"
                                Code="SetState(pPb[CONTROLID_NOINDEX][CONTROLID_INDEX], PB_DRAW_BAR);[NEWLINE]"
                                Help="Redraws the Bar only. Use after having changed ProgressBar Position"/>
                <Action Name="Get ProgressBar Range (2)"
                                Code="$Variable name where to store range:|myRange$ = PbGetRange(pPb[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]"
                                Help="Returns the current range of the progress bar"/>
                <Action Name="Set ProgressBar Range (2)"
                                Code="PbSetRange(pPb[CONTROLID_NOINDEX][CONTROLID_INDEX], $Numeric constant or variable:|100$);[NEWLINE]"
                                Help="Sets the range of the progress bar. Calling this function also resets the position equal to the new range value"/>
                <Action Name="Hide ProgressBar (2)" Code="SetState(pPb[CONTROLID_NOINDEX][CONTROLID_INDEX], PB_HIDE);[NEWLINE]" />
                <Action Name="Disable ProgressBar (2)" Code="SetState(pPb[CONTROLID_NOINDEX][CONTROLID_INDEX], PB_DISABLED);[NEWLINE]" />
                <Action Name="Enable ProgressBar (2)" Code="ClrState(pPb[CONTROLID_NOINDEX][CONTROLID_INDEX], PB_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update ProgressBar (2)" Code="SetState(pPb[CONTROLID_NOINDEX][CONTROLID_INDEX], PB_DRAW);[NEWLINE]" />
            </Actions>
        </ProgressBar>
        <RoundDial>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/RoundDial.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/RoundDial.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_ROUNDDIAL
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    ROUNDDIAL *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = RdiaCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[XCENTER],[YCENTER],[RADIUS],[STATE],[RES],[VALUE],[MAX],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="RDIA_DRAW" False="RDIA_DRAW|RDIA_DISABLED" />
                <Hidden False="RDIA_DRAW" True="RDIA_HIDE" />
            </State>
            <Events>
                <Event Name="RD_MSG_CLOCKWISE" LegacyName="" Description="RoundDial moved clockwise" PlayerEvent="MOUSE_DOWN" />
                <Event Name="RD_MSG_CTR_CLOCKWISE" LegacyName="" Description="RoundDial moved counterclockwise" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Get RoundDial Position"
                                Code="((ROUNDDIAL *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]))->value"
                                Help="Returns the current dial value. Value is always in the 0-max range inclusive"/>
                <Action Name="Get RoundDial Position and store it in a variable"
                                Code="$Variable name where to store position:|myPosition$ = ((ROUNDDIAL *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]))->value;[NEWLINE]"
                                Help="Saves the current dial value in a variable."/>
                <Action Name="Set RoundDial Position"
                                Code="RdiaSetVal((ROUNDDIAL *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), $Numeric constant or variable:|50$);"
                                Help="Sets the value to the given new value. Value set must be in 0-max range inclusive"/>
                <Action Name="Increment RoundDial Position"
                                Code="RdiaIncVal((ROUNDDIAL *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));"
                                Help="Directly increment the value. The delta change used is the resolution setting (res)."/>
                <Action Name="Decrement RoundDial Position"
                                Code="RdiaDecVal((ROUNDDIAL *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));"
                                Help="Directly decrement the value. The delta change used is the resolution setting (res)."/>
                <Action Name="Hide RoundDial" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), RDIA_HIDE);[NEWLINE]" />
                <Action Name="Disable RoundDial" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), RDIA_DISABLED);[NEWLINE]" />
                <Action Name="Enable RoundDial" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), RDIA_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update RoundDial" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), RDIA_DRAW);[NEWLINE]" />
            </Actions>
        </RoundDial>
        <Slider>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/Slider.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/Slider.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_SLIDER
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    SLIDER *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = SldCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],[RANGE],[PAGE],[POS],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="SLD_DRAW" False="SLD_DRAW|SLD_DISABLED" />
                <Hidden False="SLD_DRAW" True="SLD_HIDE" />
                <Orientation Horizontal="SLD_DRAW" Vertical="SLD_VERTICAL" />
                <SliderType Slider="SLD_DRAW" ScrollBar="SLD_SCROLLBAR" />
            </State>
            <Events>
                <Event Name="SLD_MSG_INC" LegacyName="GFX_GOL_SCROLLBAR_ACTION_INC" Description="Slider incremented" />
                <Event Name="SLD_MSG_DEC" LegacyName="GFX_GOL_SCROLLBAR_ACTION_DEC" Description="Slider decremented" />
                <Event Name="OBJ_MSG_PASSIVE" LegacyName="GFX_GOL_OBJECT_ACTION_PASSIVE" Description="Slider released" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Get Slider Position"
                                Code="((SLIDER *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]))->pos"
                                Help="Returns the current position of the slider's thumb"/>
                <Action Name="Get Slider Position and store it in a variable"
                                Code="$Variable where to store position:|myPosition$ = ((SLIDER *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]))->pos;[NEWLINE]"
                                Help="Stores the current position of the slider's thumb in a variable"/>
                <Action Name="Set Slider Position"
                                Code="((SLIDER *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]))->pos=$Numeric constant or variable:|50$;[NEWLINE]"
                                Help="Sets the position of the slider thumb. Value should be in the set range inclusive. Object must be redrawn to reflect the change"/>
                <Action Name="Get Slider Range"
                                Code="WORD range;
						range = SldGetRange((SLIDER *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Returns the current range of the thumb"/>
                <Action Name="Set Slider Range"
                                Code="SldSetRange((SLIDER *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), $Numeric constant or variable:|100$);[NEWLINE]"
                                Help="Sets the range of the thumb. If this field is changed Object must be completely redrawn to reflect the change"/>
                <Action Name="Hide Slider" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), SLD_HIDE);[NEWLINE]" />
                <Action Name="Disable Slider" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), SLD_DISABLED);[NEWLINE]" />
                <Action Name="Enable Slider" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), SLD_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update Slider" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), SLD_DRAW);[NEWLINE]" />
                <Action Name="=== Using pointer ===" Code="" />
                <Action Name="Create pointer var (mandatory)" Code="SLIDER *pSld[CONTROLID_NOINDEX][CONTROLID_INDEX]=(SLIDER *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]" />
                <Action Name="Get Slider Position (2)"
                                Code="pSld[CONTROLID_NOINDEX][CONTROLID_INDEX]->pos"
                                Help="Returns the current position of the slider's thumb"/>
                <Action Name="Get Slider Position and store it in a variable (2)"
                                Code="$Variable where to store position:|myPosition$ = pSld[CONTROLID_NOINDEX][CONTROLID_INDEX]->pos;[NEWLINE]"
                                Help="Stores the current position of the slider's thumb in a variable"/>
                <Action Name="Set Slider Position (2)"
                                Code="pSld[CONTROLID_NOINDEX][CONTROLID_INDEX]->pos=$Numeric constant or variable:|50$;[NEWLINE]"
                                Help="Sets the position of the slider thumb. Value should be in the set range inclusive. Object must be redrawn to reflect the change"/>
                <Action Name="Get Slider Range (2)"
                                Code="WORD range;
						range = SldGetRange(pSld[CONTROLID_NOINDEX][CONTROLID_INDEX]);[NEWLINE]"
                                Help="Returns the current range of the thumb"/>
                <Action Name="Set Slider Range (2)"
                                Code="SldSetRange(pSld[CONTROLID_NOINDEX][CONTROLID_INDEX], $Numeric constant or variable:|100$);[NEWLINE]"
                                Help="Sets the range of the thumb. If this field is changed Object must be completely redrawn to reflect the change"/>
                <Action Name="Hide Slider" Code="SetState(pSld[CONTROLID_NOINDEX][CONTROLID_INDEX], SLD_HIDE);[NEWLINE]" />
                <Action Name="Disable Slider" Code="SetState(pSld[CONTROLID_NOINDEX][CONTROLID_INDEX], SLD_DISABLED);[NEWLINE]" />
                <Action Name="Enable Slider" Code="ClrState(pSld[CONTROLID_NOINDEX][CONTROLID_INDEX], SLD_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update Slider" Code="SetState(pSld[CONTROLID_NOINDEX][CONTROLID_INDEX], SLD_DRAW);[NEWLINE]" />
            </Actions>
        </Slider>
        <Meter>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/Meter.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/Meter.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_METER
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    METER *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = MtrCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],[VALUE],[MINVALUE],[MAXVALUE],(void *)&[TITLEFONT],(void *)&[VALUEFONT],(XCHAR*)[WIDGETTEXT],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="MTR_DRAW" False="MTR_DRAW|MTR_DISABLED" />
                <Hidden False="MTR_DRAW" True="MTR_HIDE" />
                <MeterType Normal="MTR_DRAW" Ring="MTR_RING" />
            </State>
            <Events>
                <Event Name="MTR_MSG_SET" LegacyName="GFX_GOL_METER_ACTION_SET" Description=" Meter set value" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set Meter Value"
                                Code="MtrSetVal((METER *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), VALUE);[NEWLINE]"
                                Help="Sets the value of the meter"/>
                <Action Name="Get Meter Value"
                                Code="$Variable where to store value:|myValue$ = MtrGetVal((METER *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Gets the current value of the meter"/>
                <Action Name="Increment Meter Value"
                                Code="MtrIncVal((METER *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]),DELTAVALUE);[NEWLINE]"
                                Help="This macro is used to directly increment the value of the meter"/>
                <Action Name="Decrement Meter Value"
                                Code="MtrDecVal((METER *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]),DELTAVALUE);[NEWLINE]"
                                Help="This macro is used to directly decrement the value of the meter"/>
                <Action Name="Update Meter" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), MTR_DRAW_UPDATE);[NEWLINE]" />
                <Action Name="Hide Meter" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), MTR_HIDE);[NEWLINE]" />
                <Action Name="Show Meter" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), MTR_DRAW);[NEWLINE]" />
                <Action Name="Disable Meter" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), MTR_DISABLED);[NEWLINE]" />
                <Action Name="Enable Meter" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), MTR_DISABLED);[NEWLINE]" />
                <Action Name="Use Text Buffer name" Code="[CONTROLID_NOINDEX][CONTROLID_INDEX]_Text" />
            </Actions>
        </Meter>
        <TextEntry>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/TextEntry.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/TextEntry.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_TEXTENTRY
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <Constructor>
                <![CDATA[
    TEXTENTRY *p[CONTROLID];
]]>
            </Constructor>
            <CodeHead>
                <![CDATA[
XCHAR *[CONTROLID_NOINDEX][CONTROLID_INDEX]_KEYS[]={[KEYS]};]]>
            </CodeHead>
            <Code>
                <![CDATA[
    p[CONTROLID] = TeCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],[HORKEYS],[VERKEYS],[CONTROLID_NOINDEX][CONTROLID_INDEX]_KEYS,(XCHAR*)[CONTROLID]_Text,[BUFFERLEN],(void *)&[DISPFONT],GOLScheme_[SCHEME]);
    // Conditional key assignment.
    // The following TeSetKeyCommand are wrapped inside #if/#endif pre-processor statements so that only assigned keys statements will be compiled and executed
    #if ([ENTERKEYIDX] != -1)
        TeSetKeyCommand(p[CONTROLID],[ENTERKEYIDX],TE_ENTER_COM);
    #endif
    #if ([DELETEKEYIDX] != -1)
        TeSetKeyCommand(p[CONTROLID],[DELETEKEYIDX],TE_DELETE_COM);
    #endif
    #if ([SPACEKEYIDX] != -1)
        TeSetKeyCommand(p[CONTROLID],[SPACEKEYIDX],TE_SPACE_COM);
    #endif
]]>
            </Code>
            <State>
                <Enabled True="TE_DRAW" False="TE_DRAW|TE_DISABLED" />
                <Hidden False="TE_DRAW" True="TE_HIDE" />
                <EchoHide True="TE_DRAW|TE_ECHO_HIDE" False="TE_DRAW" />
            </State>
            <Events>
                <Event Name="TE_MSG_ADD_CHAR" LegacyName="GFX_GOL_TEXTENTRY_ACTION_ADD_CHAR" Description="TextEntry character inserted" />
                <Event Name="TE_MSG_DELETE" LegacyName="GFX_GOL_TEXTENTRY_ACTION_DELETE" Description="TextEntry character removed" />
                <Event Name="TE_MSG_ENTER" LegacyName="GFX_GOL_TEXTENTRY_ACTION_ENTER" Description="TextEntry Enter key pressed" />
                <Event Name="TE_MSG_SPACE" LegacyName="GFX_GOL_TEXTENTRY_ACTION_SPACE" Description="TextEntry Space key pressed" />
                <Event Name="TE_MSG_PRESSED" LegacyName="GFX_GOL_TEXTENTRY_ACTION_PRESSED" Description="TextEntry touched" PlayerEvent="MOUSE_DOWN" />
                <Event Name="TE_MSG_RELEASED" LegacyName="GFX_GOL_TEXTENTRY_ACTION_RELEASED" Description="TextEntry released" PlayerEvent="MOUSE_UP" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Clear Text Buffer"
                                Code="TeClearBuffer((TEXTENTRY *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="This function will clear the data in the display. You must set the drawing state bit TE_UPDATE_TEXT to update the TEXTENTRY on the screen"/>
                <Action Name="Use Text Buffer"
                                Code="XCHAR *pText;
						pText = TeGetBuffer((TEXTENTRY *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                                Help="Returns a pointer to the buffer used"/>
                <Action Name="Set TextEntry Text"
                                Code="TeSetBuffer((TEXTENTRY *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (XCHAR *)$Quoted string constant or variable:|&quot;New text&quot;$, (WORD) MaxSize);[NEWLINE]"
                                Help="This function sets the buffer used to display text. If the buffer is initialized with a string, the string must be a null terminated
							string. If the string length is greater than MaxSize, string will be truncated to MaxSize. pText must point to a valid memory
							location with size equal to MaxSize+1. The +1 is used for the string terminator"/>
                <Action Name="Hide TextEntry" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), TE_HIDE);[NEWLINE]" />
                <Action Name="Disable TextEntry" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), TE_DISABLED);[NEWLINE]" />
                <Action Name="Enable TextEntry" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), TE_DISABLED);[NEWLINE]" />
                <Action Name="Redraw edited Text" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), TE_UPDATE_TEXT);[NEWLINE]" />
                <Action Name="Show/Update TextEntry" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), TE_DRAW);[NEWLINE]" />
            </Actions>
        </TextEntry>
        <Chart>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/Graphics">
                    <AddFile>$MAL/Include/Graphics/Chart.h</AddFile>
                </Folder>
                <Folder Name="Source Files/Graphics">
                    <AddFile>$MAL/Graphics/Chart.c</AddFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_CHART]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]]]>
            </Header>
            <Constructor>
                <![CDATA[
    CHART *p[CONTROLID];]]>
            </Constructor>
            <Code>
            </Code>
            <State>
            </State>
            <Events>
            </Events>
            <Actions>
            </Actions>
        </Chart>
        <Arc>
            <GOL>No</GOL>
            <Header>
            </Header>
            <CodeHead>
            </CodeHead>
            <Constructor>
            </Constructor>
            <Code>
                <![CDATA[
    // Arc [CONTROLID_NOINDEX][CONTROLID_INDEX]
    SetColor([COLOR]);  //[COLOR_STRING]
    [STATEMENT]
]]>
            </Code>
            <Statement>
                <Fill True="while(!FillBevel([XL],[YT],[XR],[YB],[RADIUS2]));"
                              False="while(!Arc([XL],[YT],[XR],[YB],[RADIUS1],[RADIUS2],[OCTANT]));" />
            </Statement>
            <State>
            </State>
        </Arc>
        <Circle>
            <GOL>No</GOL>
            <Header>
            </Header>
            <CodeHead>
            </CodeHead>
            <Constructor>
            </Constructor>
            <Code>
                <![CDATA[
    // Circle [CONTROLID_NOINDEX][CONTROLID_INDEX]
    SetLineType([TYPE]);
    SetLineThickness([THICKNESS]);
    SetColor([COLOR]);  //[COLOR_STRING]
    while(![STATEMENT]([X],[Y],[RADIUS]));
]]>
            </Code>
            <Statement>
                <Fill True="FillCircle" False="Circle" />
            </Statement>
        </Circle>
        <Line>
            <GOL>No</GOL>
            <Header>
            </Header>
            <CodeHead>
            </CodeHead>
            <Constructor>
            </Constructor>
            <Code>
                <![CDATA[
    // Line [CONTROLID_NOINDEX][CONTROLID_INDEX]
    SetLineType([TYPE]);
    SetLineThickness([THICKNESS]);
    SetColor([COLOR]);  //[COLOR_STRING]
    while(!Line([X1],[Y1],[X2],[Y2]));
]]>
            </Code>
            <State>
            </State>
        </Line>
        <Rectangle>
            <GOL>No</GOL>
            <Header>
            </Header>
            <CodeHead>
            </CodeHead>
            <Constructor>
            </Constructor>
            <Code>
                <![CDATA[
    // Rectangle [CONTROLID_NOINDEX][CONTROLID_INDEX]
    SetColor([COLOR]);  //[COLOR_STRING]
    [STATEMENT]
]]>
            </Code>
            <Statement>
                <Fill True="while(!Bar([LEFT],[TOP],[RIGHT],[BOTTOM]));" False="SetLineType([TYPE]);
        SetLineThickness([THICKNESS]);
        Rectangle([LEFT],[TOP],[RIGHT],[BOTTOM]);" />
            </Statement>
        </Rectangle>
        <OutTextXY>
            <GOL>No</GOL>
            <Header>
            </Header>
            <CodeHead>
            </CodeHead>
            <Constructor>
            </Constructor>
            <Code>
                <![CDATA[
    // OutTextXY [CONTROLID_NOINDEX][CONTROLID_INDEX]
    SetFont((void *) &[FONT]);
    SetColor([COLOR]);	// [COLOR_STRING]
    while(!OutTextXY([LEFT],[TOP],(XCHAR*)[WIDGETTEXT])); // [TEXT]
]]>
            </Code>
            <Statement>
                <Fill True="Bar" False="Rectangle" />
            </Statement>
        </OutTextXY>
        <Gradient>
            <GOL>No</GOL>
            <GraphicsConfig>
                USE_GRADIENT
            </GraphicsConfig>
            <Header>
            </Header>
            <CodeHead>
            </CodeHead>
            <Constructor>
            </Constructor>
            <Code>
                <![CDATA[
    #ifdef USE_GRADIENT
        // Gradient [CONTROLID_NOINDEX][CONTROLID_INDEX]
        while(!BevelGradient([LEFT], [TOP], [RIGHT], [BOTTOM], [RADIUS], [COLOR1], [COLOR2], [LENGTH], [DIRECTION]));
    #endif
]]>
            </Code>
            <State>
            </State>
        </Gradient>
        <PutImage>
            <GOL>No</GOL>
            <GraphicsConfig>
            </GraphicsConfig>
            <Header>
            </Header>
            <CodeHead>
            </CodeHead>
            <Constructor>
            </Constructor>
            <Code>
                <![CDATA[
    // PutImage [CONTROLID_NOINDEX][CONTROLID_INDEX]
    [BITMAP_POINTER_INIT]
    PutImage([LEFT], [TOP], [BITMAP], [SCALE]);
]]>
            </Code>
            <State>
            </State>
        </PutImage>

        <ComboBox>
            <GraphicsConfig>
                <![CDATA[
USE_LISTBOX
USE_EDITBOX
USE_SLIDER
USE_BUTTON_MULTI_LINE
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
// ComboBox - IDs for Widgets created by [CONTROLID_NOINDEX][CONTROLID_INDEX]
]]>
            </Header>
            <Constructor>
            </Constructor>
            <Code>
                <![CDATA[
// ---------------------------------------
// ComboBox - [CONTROLID_NOINDEX][CONTROLID_INDEX]
// ---------------------------------------
]]>
            </Code>
            <State>
                <!--<Enabled True="LB_DRAW" False="LB_DRAW|LB_DISABLED" />
        <Hidden False="LB_DRAW" True="LB_HIDE" />
        <HorizAlign Left="LB_DRAW" Right="LB_RIGHT_ALIGN" Center="LB_CENTER_ALIGN" />
        <SingleSel True="LB_SINGLE_SEL" False="LB_DRAW" />-->
            </State>
            <Events>
                <!--<Event Name="LB_MSG_SEL" Description="ListBox item selected" PlayerEvent="MOUSE_DOWN" />
        <Event Name="LB_MSG_MOVE" Description="ListBox item moved" />
        <Event Name="LB_MSG_TOUCHSCREEN" Description="ListBox touchscreen selected" />-->
            </Events>
            <Actions>
                <!--<Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
        <Action Name="Hide ListBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), LB_HIDE);[NEWLINE]" />
        <Action Name="Show/Update ListBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), LB_DRAW);[NEWLINE]" />
        <Action Name="Use Text Buffer name" Code="[CONTROLID_NOINDEX][CONTROLID_INDEX]_Text" />-->
            </Actions>
        </ComboBox>

        <All>
            <Code>
                <!--if(p[CONTROLID_NOINDEX][CONTROLID_INDEX]==NULL){/*CreateError(0);*/while(1);} //Fatal Error, Check for memory leak or heap size-->
            </Code>
        </All>
        <SuperGauge>
            <GOL>Yes</GOL>
            <GraphicsConfig>
                <![CDATA[
USE_SUPERGAUGE
]]>
            </GraphicsConfig>
            <Project>
                <Folder Name="Header Files/VGDD">
                    <AddVGDDFile>SuperGauge.h</AddVGDDFile>
                    <AddVGDDFile>FontLed7Seg.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/VGDD">
                    <AddVGDDFile>SuperGauge.c</AddVGDDFile>
                    <AddVGDDFile>FontLed7Seg.c</AddVGDDFile>
                </Folder>
            </Project>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
extern WORD Segments[CONTROLID_NOINDEX][CONTROLID_INDEX][];
]]>
            </Header>
            <HeadersIncludes>
                <![CDATA[
#include "SuperGauge.h"
]]>
            </HeadersIncludes>
            <CodeHeadComment>
            </CodeHeadComment>
            <CodeHead>
            </CodeHead>
            <Constructor>
                <![CDATA[
SUPERGAUGE *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
WORD Segments[CONTROLID_NOINDEX][CONTROLID_INDEX][] = {[SEGMENTSARRAY]};
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = SgCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE]
        ,(void *)&[DIALSCALEFONT]	// pDialScaleFont
        ,(XCHAR*)[WIDGETTEXT]
        ,[SEGMENTSCOUNT]	// SegmentsCount
        ,(void *)&Segments[CONTROLID_NOINDEX][CONTROLID_INDEX]	// pSegments
        ,[PARAMETERS] // SuperGauge Parameters
        ,GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="SG_DRAW" False="SG_DRAW|SG_DISABLED" />
                <Hidden False="SG_DRAW" True="SG_HIDE" />
                <NoPanel Enabled="SG_NOPANEL" Disabled="SG_DRAW" />
                <PointerLine NORMAL_LINE="SG_DRAW" THICK_LINE="SG_POINTER_THICK" />
            </State>
            <Events>
                <Event Name="SG_MSG_TOUCHSCREEN" Description="SuperGauge has been touched" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set SuperGauge Value" Code="SgSetVal((SUPERGAUGE *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]),VALUE);[NEWLINE]" />
                <Action Name="Update SuperGauge" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), SG_DRAW_UPDATE);[NEWLINE]" />
                <Action Name="Hide SuperGauge" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), SG_HIDE);[NEWLINE]" />
                <Action Name="Show SuperGauge" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), SG_DRAW);[NEWLINE]" />
            </Actions>
        </SuperGauge>
        <Indicator>
            <GOL>Yes</GOL>
            <GraphicsConfig>
                <![CDATA[
USE_INDICATOR
]]>
            </GraphicsConfig>
            <Project>
                <Folder Name="Header Files/VGDD">
                    <AddVGDDFile>Indicator.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/VGDD">
                    <AddVGDDFile>Indicator.c</AddVGDDFile>
                </Folder>
            </Project>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <HeadersIncludes>
                <![CDATA[
#include "Indicator.h"
]]>
            </HeadersIncludes>
            <CodeHeadComment>
            </CodeHeadComment>
            <CodeHead>
            </CodeHead>
            <Constructor>
                <![CDATA[
INDICATOR *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = IndCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],[VALUE],[STYLE],[COLOUR],(XCHAR*)[WIDGETTEXT],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="IND_DRAW" False="IND_DRAW|IND_DISABLED" />
                <Hidden False="IND_DRAW" True="IND_HIDE" />
                <TextAlign Left="IND_DRAW" Right="IND_RIGHT_ALIGN" Center="IND_CENTER_ALIGN" />
                <Frame Enabled="IND_FRAME" Disabled="IND_DRAW" />
            </State>
            <Events>
                <Event Name="IND_MSG_TOUCHSCREEN" Description="Indicator has been touched" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set Indicator Value" Code="IndSetVal((INDICATOR *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]),VALUE);[NEWLINE]" />
                <Action Name="Set Indicator Colour" Code="IndSetColour((INDICATOR *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]),COLOUR);[NEWLINE]" />
                <Action Name="Update Indicator" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), IND_DRAW);[NEWLINE]" />
                <Action Name="Hide Indicator" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), IND_HIDE);[NEWLINE]" />
                <Action Name="Show Indicator" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), IND_DRAW);[NEWLINE]" />
            </Actions>
        </Indicator>
        <Disp7Seg>
            <GOL>Yes</GOL>
            <GraphicsConfig>
                <![CDATA[
USE_DISP7SEG
]]>
            </GraphicsConfig>
            <Project>
                <Folder Name="Header Files/VGDD">
                    <AddVGDDFile>Disp7Seg.h</AddVGDDFile>
                    <AddVGDDFile>FontLed7Seg.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/VGDD">
                    <AddVGDDFile>Disp7Seg.c</AddVGDDFile>
                    <AddVGDDFile>FontLed7Seg.c</AddVGDDFile>
                </Folder>
            </Project>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <HeadersIncludes>
                <![CDATA[
#include "Disp7Seg.h"
]]>
            </HeadersIncludes>
            <CodeHeadComment>
            </CodeHeadComment>
            <CodeHead>
            </CodeHead>
            <Constructor>
                <![CDATA[
DISP7SEG *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = D7Create(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],[VALUE],[NUMDIGITS],[DOTPOS],[THICKNESS],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="D7_DRAW" False="D7_DRAW|D7_DISABLED" />
                <Hidden False="D7_DRAW" True="D7_HIDE" />
                <Frame Enabled="D7_FRAME" Disabled="D7_DRAW" />
                <Style FontLed7SegBar="D7_DRAW" FontLed7SegPoly="D7_DRAWPOLY" />
            </State>
            <Events>
                <Event Name="D7_MSG_TOUCHED" Description="Disp7Seg has been touched" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set Disp7Seg Value" Code="D7SetVal((DISP7SEG *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]),VALUE);[NEWLINE]" />
                <Action Name="Increment Disp7Seg Value" Code="D7IncVal((DISP7SEG *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), deltaValue);[NEWLINE]" />
                <Action Name="Decrement Disp7Seg Value" Code="D7DecVal((DISP7SEG *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), deltaValue);[NEWLINE]" />
                <Action Name="Update Disp7Seg" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), D7_DRAW);[NEWLINE]" />
                <Action Name="Hide Disp7Seg" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), D7_HIDE);[NEWLINE]" />
                <Action Name="Show Disp7Seg" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), D7_DRAW);[NEWLINE]" />
            </Actions>
        </Disp7Seg>
        <VuMeter>
            <GOL>Yes</GOL>
            <GraphicsConfig>
                <![CDATA[
USE_VUMETER
]]>
            </GraphicsConfig>
            <Project>
                <Folder Name="Header Files/VGDD">
                    <AddVGDDFile>VuMeter.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/VGDD">
                    <AddVGDDFile>VuMeter.c</AddVGDDFile>
                </Folder>
            </Project>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <HeadersIncludes>
                <![CDATA[
#include "VuMeter.h"
]]>
            </HeadersIncludes>
            <CodeHeadComment>
            </CodeHeadComment>
            <CodeHead>
            </CodeHead>
            <Constructor>
                <![CDATA[
VUMETER *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    [BITMAP_POINTER_INIT]
        p[CONTROLID_NOINDEX][CONTROLID_INDEX] = VuCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM]
        ,[STATE] // State
        ,[PARAMETERS] // VuMeter Parameters
        ,[BITMAP] // Bitmap
        ,GOLScheme_[SCHEME]);
]]>
            </Code>
            <ScreenCode Event="SCREEN_DISPLAY">
                <![CDATA[
    // This code ensures VuMeter [CONTROLID_NOINDEX][CONTROLID_INDEX] gets animated across GolDraw() calls
    if(GetState(p[CONTROLID_NOINDEX][CONTROLID_INDEX], VU_DRAW_ANIMATING)) {
        SetState(p[CONTROLID_NOINDEX][CONTROLID_INDEX], VU_DRAW_UPDATE);
    }
]]>
            </ScreenCode>
            <State>
                <Enabled True="VU_DRAWALL" False="VU_DRAWALL|VU_DISABLED" />
                <Hidden False="VU_DRAWALL" True="VU_HIDE" />
                <Frame Enabled="VU_FRAME" Disabled="VU_DRAWALL" />
                <PointerLine NORMAL_LINE="VU_DRAWALL" THICK_LINE="VU_POINTER_THICK" />
            </State>
            <Events>
                <Event Name="VU_MSG_TOUCHSCREEN" Description="VuMeter has been touched" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set VuMeter Value" Code="VuSetVal((VUMETER *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]),VALUE);[NEWLINE]" />
                <Action Name="Redraw all VuMeter" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), VU_DRAWALL);[NEWLINE]" />
                <Action Name="Update VuMeter Pointer" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), VU_DRAW_UPDATE);[NEWLINE]" />
                <Action Name="Hide VuMeter" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), VU_HIDE);[NEWLINE]" />
            </Actions>
        </VuMeter>
        <BarGraph>
            <GOL>Yes</GOL>
            <GraphicsConfig>
                <![CDATA[
USE_BARGRAPH
]]>
            </GraphicsConfig>
            <Project>
                <Folder Name="Header Files/VGDD">
                    <AddVGDDFile>BarGraph.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/VGDD">
                    <AddVGDDFile>BarGraph.c</AddVGDDFile>
                </Folder>
            </Project>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
extern BgSegment Segments[CONTROLID_NOINDEX][CONTROLID_INDEX][];
]]>
            </Header>
            <HeadersIncludes>
                <![CDATA[
#include "BarGraph.h"
]]>
            </HeadersIncludes>
            <CodeHeadComment>
            </CodeHeadComment>
            <CodeHead>
            </CodeHead>
            <Constructor>
                <![CDATA[
BgSegment Segments[CONTROLID_NOINDEX][CONTROLID_INDEX][] = {[SEGMENTSARRAY]};
BARGRAPH *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = BgCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM]
        ,[STATE] // State
        ,[SEGMENTSCOUNT] // Segments Count
        ,(void *)&Segments[CONTROLID_NOINDEX][CONTROLID_INDEX]	// pSegments
        ,[PARAMETERS] // BarGraph Parameters
        ,GOLScheme_[SCHEME]);
]]>
            </Code>
            <ScreenCode Event="SCREEN_DISPLAY">
                <![CDATA[
    // This code ensures BarGraph [CONTROLID_NOINDEX][CONTROLID_INDEX] gets animated across GolDraw() calls
    if(GetState(p[CONTROLID_NOINDEX][CONTROLID_INDEX], BG_DRAW_ANIMATING)) {
        SetState(p[CONTROLID_NOINDEX][CONTROLID_INDEX], BG_DRAW_UPDATE);
    }
]]>
            </ScreenCode>
            <State>
                <Enabled True="BG_DRAWALL" False="BG_DRAWALL|BG_DISABLED" />
                <Hidden False="BG_DRAWALL" True="BG_HIDE" />
                <Frame Enabled="BG_FRAME" Disabled="BG_DRAWALL" />
                <Orientation Horizontal="" Vertical="BG_VERTICAL" />
            </State>
            <Events>
                <Event Name="BG_MSG_TOUCHSCREEN" Description="BarGraph has been touched" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set BarGraph Value" Code="BgSetVal((BARGRAPH *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]),VALUE);[NEWLINE]" />
                <Action Name="Redraw all BarGraph" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), BG_DRAWALL);[NEWLINE]" />
                <Action Name="Update BarGraph Pointer" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), BG_DRAW_UPDATE);[NEWLINE]" />
                <Action Name="Hide BarGraph" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), BG_HIDE);[NEWLINE]" />
            </Actions>
        </BarGraph>
        <MsgBox>
            <GOL>Yes</GOL>
            <GraphicsConfig>
                <![CDATA[
USE_MSGBOX
USE_BUTTON_MULTI_LINE
]]>
            </GraphicsConfig>
            <Project>
                <Folder Name="Header Files/VGDD">
                    <AddVGDDFile>MsgBox.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/VGDD">
                    <AddVGDDFile>MsgBox.c</AddVGDDFile>
                </Folder>
            </Project>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <HeadersIncludes>
                <![CDATA[
#include "MsgBox.h"
]]>
            </HeadersIncludes>
            <CodeHeadComment>
            </CodeHeadComment>
            <CodeHead>
            </CodeHead>
            <Constructor>
                <![CDATA[
MSGBOX *p[CONTROLID_NOINDEX][CONTROLID_INDEX];]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = MsgBoxCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM]
        ,[RADIUS] // Radius
        ,[BUTTONSTODISPLAY] // Buttons to display
        ,(XCHAR*)[WIDGETTEXT] // Main message
        ,(XCHAR*)[CAPTIONTEXT] // Caption message
        ,[STATE] // State
        ,[BITMAP] // Bitmap for main message
        ,[CAPTIONBITMAP] // Bitmap for the caption
        ,GOLScheme_[SCHEME] // GOL Scheme for MsgBox body
        ,GOLScheme_[BUTTONS_SCHEME] // GOL Scheme for the buttons
        ,[RELEASEDKEY_BITMAP] // Bitmap for the released key
        ,[PRESSEDKEY_BITMAP] // Bitmap for the pressed key
        );
]]>
            </Code>
            <State>
                <Hidden False="MSGBOX_DRAW" True="MSGBOX_HIDE" />
                <HorizAlign Left="MSGBOX_TEXTLEFT" Right="MSGBOX_TEXTRIGHT" Center="MSGBOX_DRAW" />
                <VertAlign Top="MSGBOX_TEXTTOP" Bottom="MSGBOX_TEXTBOTTOM" Center="MSGBOX_DRAW" />
            </State>
            <Events>
                <Event Name="MSGBOX_TOUCHSCREEN" Description="MessageBox has been touched" />
                <Event Name="MSGBOX_MSG_OK_YES" Description="User touched the OK/YES button" />
                <Event Name="MSGBOX_MSG_NO" Description="User touched the NO button" />
                <Event Name="MSGBOX_MSG_CANCEL" Description="User touched the CANCEL button" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set MsgBox Main text" Code="MsgBoxSetText((MSGBOX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]),VALUE);[NEWLINE]" />
                <Action Name="Redraw MsgBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), MSGBOX_DRAW);[NEWLINE]" />
                <Action Name="Hide MsgBox" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), MSGBOX_HIDE);[NEWLINE]" />
                <Action Name="Show MsgBox" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), MSGBOX_HIDE);[NEWLINE]" />
            </Actions>
        </MsgBox>
        <TextEntryEx>
            <GOL>Yes</GOL>
            <GraphicsConfig>
                <![CDATA[
USE_TEXTENTRYEX
]]>
            </GraphicsConfig>
            <Project>
                <Folder Name="Header Files/VGDD">
                    <AddVGDDFile>TextEntryEx.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/VGDD">
                    <AddVGDDFile>TextEntryEx.c</AddVGDDFile>
                </Folder>
            </Project>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <HeadersIncludes>
                <![CDATA[
#include "TextEntryEx.h"
]]>
            </HeadersIncludes>
            <CodeHeadComment>
            </CodeHeadComment>
            <CodeHead>
                <![CDATA[
XCHAR *[CONTROLID_NOINDEX][CONTROLID_INDEX]_KEYS[]={[KEYS]};
XCHAR *[CONTROLID_NOINDEX][CONTROLID_INDEX]_KEYSALTERNATE[]={[KEYSALTERNATE]};
XCHAR *[CONTROLID_NOINDEX][CONTROLID_INDEX]_KEYSSHIFT[]={[KEYSSHIFT]};
XCHAR *[CONTROLID_NOINDEX][CONTROLID_INDEX]_KEYSSHIFTALTERNATE[]={[KEYSSHIFTALTERNATE]};
]]>
            </CodeHead>
            <Constructor>
                <![CDATA[
TEXTENTRYEX *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID] = TeExCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM]
        ,[STATE] // Initial state for the Widget
        ,[CONTROLID_NOINDEX][CONTROLID_INDEX]_KEYS // Array of key texts
        ,[CONTROLID_NOINDEX][CONTROLID_INDEX]_KEYSALTERNATE // Array of alternate key texts
        ,[CONTROLID_NOINDEX][CONTROLID_INDEX]_KEYSSHIFT // Array of shift key texts
        ,[CONTROLID_NOINDEX][CONTROLID_INDEX]_KEYSSHIFTALTERNATE // Array of shift key texts
        ,(INT16[])[COMMANDKEYS] // Command key indexes
        ,(XCHAR*)[CONTROLID]_Text // Buffer of typed text
        ,[BITMAPPRESSED] // Bitmap for pressed key
        ,[BITMAPRELEASED] // Bitmap for released key
        ,(void *)&[DISPFONT] // Font for displaying typed text
        ,[PARAMETERS] // TextEntryEx Parameters
        ,GOLScheme_[SCHEME] // Scheme
        );
]]>
            </Code>
            <!--<CodeSub1>
          TeExSetKeyCommand(p[CONTROLID],[KEYIDX],[KEYCOMMAND]);
        </CodeSub1>-->
            <ScreenCode>
            </ScreenCode>
            <State>
                <Enabled True="TEEX_DRAW" False="TEEX_DRAW|TEEX_DISABLED" />
                <Hidden False="TEEX_DRAW" True="TEEX_HIDE" />
                <Frame Enabled="TEEX_FRAME" Disabled="TEEX_DRAW" />
                <KeysLayout Gruid="TEEX_DRAW" KeyboardLike="TEEX_LIKEKEYBOARD" />
            </State>
            <Events>
                <Event Name="TEEX_MSG_PRESSED" Description="A key has been pressed" />
                <Event Name="TEEX_MSG_RELEASED" Description="A key has been released" />
                <Event Name="TEEX_MSG_ENTER" Description="Enter (OK) key has been touched" />
                <Event Name="TEEX_MSG_ADD_CHAR" Description="A character has been added" />
                <Event Name="TEEX_MSG_SHIFT" Description="Shift key has been touched" />
                <Event Name="TEEX_MSG_BKSP" Description="Backspace key has been touched" />
                <Event Name="TEEX_MSG_SPACE" Description="Space key has been touched" />
                <Event Name="TEEX_MSG_ALTERNATE" Description="Alt (?123/abc) key has been touched" />
                <Event Name="TEEX_MSG_CAPSLOCK" Description="Shift key has been pressed for more than about 1 second" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Hide TextEntryEx" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), TEEX_HIDE);[NEWLINE]" />
                <Action Name="Disable TextEntryEx" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), TEEX_DISABLED);[NEWLINE]" />
                <Action Name="Enable TextEntryEx" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), TEEX_DISABLED);[NEWLINE]" />
                <Action Name="Redraw edited Text" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), TEEX_UPDATE_TEXT);[NEWLINE]" />
                <Action Name="Show/Update TextEntryEx" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), TEEX_DRAW);[NEWLINE]" />
                <Action Name="Clear Text Buffer"
                        Code="TeExClearBuffer((TEXTENTRYEX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                        Help="This function will clear the data in the display. You must set the drawing state bit TEEX_UPDATE_TEXT to update the TEXTENTRYEX on the screen"/>
                <Action Name="Use Text Buffer"
                        Code="XCHAR *pText;
			        	pText = TeExGetBuffer((TEXTENTRYEX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]));[NEWLINE]"
                        Help="Returns a pointer to the buffer used"/>
                <Action Name="Set TextEntryEx Text"
                        Code="TeExSetBuffer((TEXTENTRYEX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (XCHAR *)$Quoted string constant or variable:|&quot;New text&quot;$, (WORD) MaxSize);[NEWLINE]"
                        Help="This function sets the buffer used to display text. If the buffer is initialized with a string, the string must be a null terminated
			        	string. If the string length is greater than MaxSize, string will be truncated to MaxSize. pText must point to a valid memory
						location with size equal to MaxSize+1. The +1 is used for the string terminator"/>
            </Actions>
        </TextEntryEx>
        <StaticTextEx>
            <GOL>Yes</GOL>
            <Project>
                <Folder Name="Header Files/VGDD">
                    <AddVGDDFile>StaticTextEx.h</AddVGDDFile>
                </Folder>
                <Folder Name="Source Files/VGDD">
                    <AddVGDDFile>StaticTextEx.c</AddVGDDFile>
                </Folder>
            </Project>
            <GraphicsConfig>
                <![CDATA[
USE_STATICTEXTEX
]]>
            </GraphicsConfig>
            <Header>
                <![CDATA[
#define ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]   [NEXT_NUMID]
]]>
            </Header>
            <HeadersIncludes>
                <![CDATA[
#include "StaticTextEx.h"
]]>
            </HeadersIncludes>
            <Constructor>
                <![CDATA[
STATICTEXTEX *p[CONTROLID_NOINDEX][CONTROLID_INDEX];
]]>
            </Constructor>
            <Code>
                <![CDATA[
    p[CONTROLID_NOINDEX][CONTROLID_INDEX] = StExCreate(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX],[LEFT],[TOP],[RIGHT],[BOTTOM],[STATE],(XCHAR*)[WIDGETTEXT],GOLScheme_[SCHEME]);
]]>
            </Code>
            <State>
                <Enabled True="STEX_DRAW" False="STEX_DRAW|STEX_DISABLED" />
                <Hidden False="STEX_DRAW" True="STEX_HIDE" />
                <HorizAlign Left="STEX_DRAW" Right="STEX_RIGHT_ALIGN" Center="STEX_CENTER_ALIGN" />
                <Frame Enabled="STEX_FRAME" Disabled="STEX_DRAW" />
                <NoPanel Enabled="STEX_NOPANEL" Disabled="STEX_DRAW" />
            </State>
            <Events>
                <Event Name="STEX_MSG_SELECTED" Description="StaticTextEx selected" PlayerEvent="MOUSE_DOWN" />
            </Events>
            <Actions>
                <Action Name="Use Widget ID" Code="ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]" />
                <Action Name="Set StaticTextEx Text"
                                Code="StExSetText((STATICTEXTEX *)GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), (XCHAR *) $Quoted string constant or variable:|&quot;New text&quot;$);[NEWLINE]"
                                Help="Sets the string that will be used for the object"/>
                <Action Name="Get StaticTextEx Text"
                                Code="XCHAR *pText;
pText=((STATICTEXTEX *)(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX])))->pText;[NEWLINE]"
                                Help="Returns the pointer to the text string used"/>
                <Action Name="Hide StaticTextEx" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), STEX_HIDE);[NEWLINE]" />
                <Action Name="Disable StaticTextEx" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), STEX_DISABLED);[NEWLINE]" />
                <Action Name="Enable StaticTextEx" Code="ClrState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), STEX_DISABLED);[NEWLINE]" />
                <Action Name="Show/Update StaticTextEx" Code="SetState(GOLFindObject(ID_[CONTROLID_NOINDEX][CONTROLID_INDEX]), STEX_DRAW);[NEWLINE]" />
                <Action Name="Use Text Buffer name" Code="[CONTROLID_NOINDEX][CONTROLID_INDEX]_Text" />
            </Actions>
        </StaticTextEx>
    </ControlsTemplates>
    <StringsPoolTemplate>
        <WidgetsText>
            <NoTranslations>
                <Header>
                </Header>
                <Code>
                    <![CDATA[
[CONTROLID_NOINDEX]_Text[CONTROLID_INDEXPAR]
]]>
                </Code>
            </NoTranslations>
            <Translations>
                <Header>
                    <![CDATA[
#define [CONTROLID_NOINDEX]_Text[CONTROLID_INDEXPAR] VGDDString([STRINGID])
]]>
                </Header>
                <Code>
                    <![CDATA[
[CONTROLID_NOINDEX]_Text[CONTROLID_INDEXPAR]
]]>
                </Code>
            </Translations>
        </WidgetsText>
        <Header>
            <![CDATA[
#define STRINGSPOOL_SIZE [NUMSTRINGS]
#define LANGUAGES_SUPPORTED [NUMTRANSLATIONS]
extern XCHAR *aVGDDStringsPool[STRINGSPOOL_SIZE][LANGUAGES_SUPPORTED];
extern BYTE VGDDActiveLanguage;
XCHAR *VGDDString(int StringID);
]]>
        </Header>
        <StringsTemplate>
            <![CDATA[
[TAB]// VGDDString([STRINGID]) [INUSE]: [QTEXT][NEWLINE]
[TAB]{ [TRANSLATIONS]
[TAB]}[COMMA][NEWLINE]
]]>
        </StringsTemplate>
        <TranslationsTemplate>
            <NoMultiChar>
                <![CDATA[
[INDENT](XCHAR *)[STRING][COMMA][NEWLINE]
]]>
            </NoMultiChar>
            <MultiChar>
                <![CDATA[
[INDENT](XCHAR [[STRINGLEN+1]]) [STRING][COMMA] //[QTEXT][NEWLINE]
]]>
            </MultiChar>
        </TranslationsTemplate>
        <StringsPoolHeaderDefine>
            <![CDATA[            
STRING_[REFSTRING]
]]>
        </StringsPoolHeaderDefine>
        <StringsPoolHeader>
            <![CDATA[            
// StringsPool.h - DO NOT EDIT THIS FILE
[STRINGSPOOLDEFINES]
]]>
        </StringsPoolHeader>
        <Code>
            <![CDATA[
// StringsPool.c - DO NOT EDIT THIS FILE
        
#include "Graphics/Graphics.h"
#include "VGDD_[PROJECT_NAME]_Screens.h"

BYTE VGDDActiveLanguage=0;

XCHAR *aVGDDStringsPool[STRINGSPOOL_SIZE][LANGUAGES_SUPPORTED] = {
[STRINGSPOOL]
};

// -------------------------------------------------------------------------------------
// Function VGDDString
// -------------------------------------------------------------------------------------
// This is the main StringsPool handler. 
// Call it by passing the StringID and it returns the pointer 
// to the translated string, according to current language settings (VGDDActiveLanguage)
// If a translation is not available, it returns the Reference string
// -------------------------------------------------------------------------------------

XCHAR *VGDDString(int StringID) {
    XCHAR *string;
    if(StringID==-1) return((XCHAR*)"");
    string = aVGDDStringsPool[StringID][VGDDActiveLanguage];
    if (string[0] == 0) {
        string = aVGDDStringsPool[StringID][0];
    }
    return (string);
}

// -------------------------------------------------------------------------------------
// Function FilteredFontTranslate
// -------------------------------------------------------------------------------------
// For strings that use a filtered font, this function translates an ASCII string to 
// the correct sequence of characters, according to the FilterTable definition
// Example:  FilteredFontTranslate("This is an ASCII String", BufTo, TahomaRegular68_FilterTable, sizeof(TahomaRegular68_FilterTable));

void FilteredFontTranslate(char *BufFrom, char *BufTo, const UINT16 *FilterTable, int FilterTableSize) {
    char c;
    UINT8 i;
    while ((c = *BufFrom)) {
        *BufTo = 0x20;
        for (i = 0; i<FilterTableSize; i++) {
            if (*(FilterTable + i) == c) {
                *BufTo = i + 0x20;
                break;
            }
        }
        BufFrom++;
        BufTo++;
    }
    *BufTo = 0x00;
}
]]>
        </Code>
    </StringsPoolTemplate>
    <ClosingBlock>
        <Header>
            <![CDATA[
#define	VGDD_NUM_SCREENS	[VGDD_NUM_SCREENS] // Number of Screens in this VGDD project
#define	VGDD_LAST_ID	[VGDD_LAST_ID] // Last Widget ID used by VGDD - You can start from VGDD_LAST_ID+1 for extra-VGDD Widgets
#define SCREENSTATE_INIT [FIRST_SCREEN_IN_PROJECT]
#endif // ifndef _VGDD_SCREENS_H_
]]>
        </Header>
        <Code>
            <![CDATA[
[EMPTYLINE]
// End of [PROJECTFILENAME_SCREENSC]
]]>
        </Code>
    </ClosingBlock>
</VGDDCodeTemplate>